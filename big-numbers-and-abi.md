# Big Numbers and ABI

### BigNumbers

The maximum value for `uint256` is from `0` to `(2^256) - 1`.:

`115792089237316195423570985008687907853269984665640564039457584007913129639935`

We usually build interfaces for smart contracts in Javascript. <mark style="color:orange;">Javascript's</mark> <mark style="color:orange;"></mark><mark style="color:orange;">`number`</mark> <mark style="color:orange;"></mark><mark style="color:orange;">data type has a significantly smaller upper limit.</mark> `max value =>` 9007199254740991

So, let's say we use Javascript to call a function on a smart contract that returns a `uint256`. If that number is greater than Javascript's maximum numeric value, which is quite definitely possible, then what happens?

We have to use **a special type** called a **`BigNumber`**

<mark style="color:orange;">ethers.js and web3.js</mark> - both come with support for <mark style="color:orange;">BigNumbers.</mark>

**BigNumber** is a custom class library (Javascript) that introduces it's own functions for mathematical functions

* `.add()` and `.mul()` instead of the typical `+` and `*`&#x20;
* **significantly larger capacity** for numbers than what Javascript can natively support

### ABI (**A**pplication **B**inary **I**nterface)

Solidity code is compiled down to bytecode (essentially binary)

* Bytecode contains **no record of function names that existed in the contract**, what parameters they contain, and what values they return.

If you want to call a Solidity function from a web app, you need a way to call the correct bytecode in the contract. To do this, you need a way to convert human-readable function names and parameters into bytecode and back.

**ABIs** help us achieve exactly that. When you compile your Solidity code, an ABI is automatically generated by the compiler.

* <mark style="color:orange;">It contains rules and metadata about functions present in the contract, which help in doing the proper data conversion back and forth.</mark>

When you want to call a contract

* Need its address (of course)
* Need to provide its ABI.

Libraries like **ether.js** use the **ABI** to **encode and decode** the **human readable functions into bytecode** **and back** when communicating with an Ethereum node and calling functions in smart contracts.
